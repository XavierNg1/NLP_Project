 Because the very central core of any dynamic web presence is its database and processing of data, our first vital goal is to make a far-reaching decision on a database engine. It is not a good idea to hope to casually make such a decision in just some seeming, most reasonable initial manner.


The vital object of this first decision is to plan our project in a manner (with tools and database engines) which will support your needs all the way down a road through a future, in which, because you made the right initial decisions, you will build effectively upon your initial foundation, efficiently and without eventual obstruction. This means that ideally for instance, the database engine you choose isn't just the easy, or seemingly simple one to deploy today; from the beginning it must be an engine which will support your downstream processing demands.
Sometimes commercial considerations further affect such choices. What engines are attendance intensive (and costly)? What engines are virtually attendance free in implementations sustaining the processing goals your eventual project must sustain? Generally, the pattern to follow is to select your engine based on one of two possible dispositions.
To do so, you must first chart out your basic table needs. A professional won't even need to build this map (regardless even if hundreds or thousands of tables are involved), because they will usually immediately see whether the architecture and future needs you will need to support are either read or write intensive. You will then choose an appropriate database, based on this overall disposition, and perhaps further based on personal taste and experience, as working with respective software development tools may predicate. MySQL is the usual choice for read intensive implementations. Many developers look to databases such as PostgreSQL for reliable write intensive implementations. We develop our dispositions toward such vital tools by careful research, and by drawing on the pool of experience of the general software development industry. Expense can generally be avoided, because free deployments of very good tools are available. What we're looking for is performance in either read or write intensive environments, reliability, ease and minimization of administration, and ready integration with prospective software development tools.;
, There are two patterns to consider in choosing software development tools. Purportedly "easy" tools are rarely in fact easy, when a project inevitably breaks the cast of the development and functionality patterns "easy" tools are generally limited to. Should you want to do something beyond the "easy" tools such as incorporate a language or translation parameter in dynamically generated URLS, it may be so much more difficult to accomplish in the "easy" tools that it may take extremely sophisticated programming skills to as much as trick the easy pattern into doing more complex things. We must master our tools to build good projects. This does not make easy tools the best choice, or the most sophisticated tools a difficult proposition. The trap of "easy" development generally comprises limitations which become very costly to overcome in the inevitable evolution of projects. A huge variety of such tools generally arises, ostensibly meeting such needs. But the pattern of the tools' persistence betrays an ostensible fact of having accomplished this goal; and so, generally we find that the most sophisticated and powerful tools, following good patterns (or availability of objects and libraries), not only alleviate practically inevitable obstructions to easy tools, but likewise then make "getting there" a far more straightforward process. When we examine the scope of available tools, generally less comprehensive models are presented in initial development concepts, and better concepts are offered by later arising tools (or they wouldn't have a chance to survive in markets which have already been won). If we choose a purportedly easy tool then, what we're looking for is a development pattern which is both wieldy and without eventual obstruction. The paradox for the neophyte then is the difficulty of seeing so far down the road that we can perceive programming obstructions to a given tool set. Some people believe the best tools are the most powerful and the least restrictive in terms of project approach. Freedom to develop what you want and need often means breaking the general model of ostensibly simple tools then, the challenges of which can practically break the brain of the most seasoned and sophisticated software engineer, because succeeding in such an object means making the "simple" model do something it may have no native capacity for supporting. Is "Ruby" for instance really an easier tool than fundamental C++ or C#? No. Not really, especially if you have to break the simple model of Ruby to deliver vital functionality. Like Ruby, GCC is free for Linux and OSX. Ruby also comes on OSX ― you just have to discover it on your system. Of the purportedly easier tools, my personal choice is Ruby. Of the truly sophisticated tools, C++ and C# will reign supreme long into the future; and the truth is, these are the only vehicles for development without obstruction. So sit up straight and brace for serious study, because regardless the road you choose, you are going to have to master not only your tools, but the potentially restrictive models which those tools might eventually encumber you with. Ruby is probably far more clean than almost all its "easy" peers. C++ is the tool of unencumbered excellence; and in fact, seasoned gurus will turn out peerless projects probably with far less difficulty than they might accomplish the same goals with a purportedly easy tool. In the end, developers who stray from this observation pay some price: either pick the most conducive "easy" tool, or worry less over the freedom from encumbrance in the most sophisticated tool. In the latter case, you master Fast CGI objects, take the ball and run. Huge concepts are implemented often with little code. Yes, simple tools make the same claim, but by abstracting ostensible difficulty away from us in such ways that deviating from their usually singular pattern poses very difficult engineering challenges, in addition to performance handicaps which C++ resolves.
 This means grabbing the best literature for tools we want to compare, and at least giving our concept some form in which it might take in a given set of tools, as compared to others. Before you choose Ruby for instance, you might pick up vital books such as "The Ruby Programming Language," and "Agile Web Development with Rails." Your initial study must not only sufficiently master the tools, it must envision how you can get there ― how you can provide desired functionality with the tool you might choose. This is a daunting task for the initiate. If you are going to compare a purportedly easy development environment to the best of the best, you're going to have to evaluate the best C tools as well. If you're really going to be a seasoned engineer, you're going to pick C for its freedom from limitation. Is C really more difficult? No. Syntax is syntax. In the end, you have to master expressing the same functionality; and in truth, the C family of languages is excellent. The difficult thing about excelling right out the gate in C++ is putting your hands on the models you might need to build upon. An excellent start from practically 15 years ago was the original FastCGI components which were available in Borland's CPPBuilder ― probably still the best C++ for Windows. Even C initiates can go far with such object oriented approaches, because the general model of sustaining functionality is built into the very things you work with. Your work is far more free-flowing than it can be in Ruby for instance, whenever you might break or exceed the Ruby model in your approach. On the other hand, Rails scaffolding techniques expedite much work for the neophyte, if and only if the project fits the general mold of Ruby and Rails. Introduce rudimentary security provisions for instance, recognized in all your Ruby interfaces however, and the next thing you know, you're re-writing a thousand lines of auto-generated Ruby code for every table your application negotiates. Is that easy? Well, I do it with a Windows editor called NoteTab Pro, operating on Ruby projects residing on an OSX system; and sophisticated macros make my revisions in perhaps a second, customizing a thousand lines of code into almost twice that. Still, this relates to relatively simple, basic functionality, which a project is restricted to. The fact is, in C++ we can write our own objects which handle these tasks truly universally ― you'd never even have to replicate this process. So these are the trade-offs. In the end, object oriented C is the most powerful and efficient. Which means it's the least work as well.
 Generally, seasoned developers rely on W3C.org for vital material.
webpage

