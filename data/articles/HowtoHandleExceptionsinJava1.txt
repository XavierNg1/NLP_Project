 Create a class and name it however you want and inside the class create the main method.




public class HandleExceptionExample {
    public static void main(String[] args) {
 
    }
}


;
, Declare three int (primitive integer) variables and name them dividend, divisor and quotient. Assign an arbitrary number to dividend variable, assign zero to divisor variable and assign quotient of dividend and divisor to quotient variable. Print quotient variable to the console.




public class HandleExceptionExample {
    public static void main(String[] args) {
        int dividend = 50;
        int divisor = 0;
        int quotient = dividend / divisor;
        System.out.println(quotient);
    }
}




, Program prints exception stack trace to the console and terminates the execution at the line where the quotient variable is assigned a value. Quotient variable will never be printed to the console because uncaught exceptions, on the line they were thrown, break out of the method.




Exception in thread "main" java.lang.ArithmeticException: / by zero
        at HandleExceptionExample.main(HandleExceptionExample.java:5)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)




, Assign a number zero to the quotient variable and create try-catch block with ArithmeticException in the catch statement. Inside the try block, divide dividend and divisor variables and assign their quotient to the quotient variable. Inside the catch block, print the exception stack trace to the console. After the try-catch block, print the quotient variable to the console.




public class HandleExceptionExample {
    public static void main(String[] args) {
        int dividend = 50;
        int divisor = 0;
        int quotient = 0;
        try {
            quotient = dividend / divisor;
        } catch (ArithmeticException e) {
            e.printStackTrace();
        }
        System.out.println(quotient);
    }
}




, Program prints exception stack trace to the console, but does not terminate the execution at the line where the quotient variable is assigned a value. Quotient variable is also printed to the console, but before the exception.




0
java.lang.ArithmeticException: / by zero
        at HandleExceptionExample.main(HandleExceptionExample.java:7)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)




, finally blocks are always executed after the try and/or catch blocks and they are mostly used to release the resources. Instead of after the try-catch-finally block, print the quotient variable to the console inside the finally block.




public class HandleExceptionExample {
    public static void main(String[] args) {
        int dividend = 50;
        int divisor = 0;
        int quotient = 0;
        try {
            quotient = dividend / divisor;
        } catch (ArithmeticException e) {
            e.printStackTrace();
        } finally {
            System.out.println(quotient);
        }
    }
}




, Program prints exception stack trace, and quotient variable right after, to the console.




java.lang.ArithmeticException: / by zero
        at HandleExceptionExample.main(HandleExceptionExample.java:11)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
0




